#' Find enriched pathways represented by a significant PSN
#'
#' Remove the excessive context-specific pathways (ban_list).
#' Remove the pathways which size is bigger than max_size (max_size:200).
#' Keep the (n_top_pathways:50) having the highest number of significant elements (sign_df).
#' For each pathway (pathways_l), use the significant molecule's values (counts) to compute how much each pair
#' of samples is similar and build the similarity network.
#' Compute the Separability Power for each network.
#'
#' @param counts numeric matrix, samples at the columns and molecules at the row (e.g. gene expression matrix)
#' @param groups character or factor vector of labels s.t. each label indicates the belonging of a sample to one group
#' @param pathways_l list of pathways
#' @param sign_df dataframe generated by find_SDR, contains the result of the differential expression analysis
#' @param pathway_type Default generic_pathway, label indicating the type of pathways (e.g. "gene_canonical_pathways")
#' @param count_source label sequencing, label indicating the source used to find the significant molecules (e.g. "gene_expression", "mutation")
#' @param max_size Default 200, integer filtering out the pathways with more original elements than this threshold
#' @param min_elements Default 5, integer filtering out the pathways containing less than this threshold of significant molecules
#' @param n_top_pathways Default 100, integer setting how many best pathway-specific PSNs to retrieve
#' @param n_cores Default 2, integer setting the number of cores to use for running the function in parallel
#' @param keep_PSN Default FALSE, boolean, do not keep the PSN generated from a pathway
#' @param ban Default TRUE, boolean, remove excessive context-specific pathways (e.g. "SOUND", "STABILIZATION", "ODONTOGENESIS", "PREGNANCY")
#' @return list of three elements: top_pathways_l, top_pathways_df and top_pathways_el
#' top_pathways_df details the pathways/sets which have a significant PSN.
#' It describes them with the following column features:
#'
#' - pathway name
#'
#' - freq: number of significant molecules belonging to the pathway
#'
#' - regulation: direction of deregulation
#'
#' - groups: indicates the group of patients/nodes being significantly more similar than the opposite group in comparison
#'
#' - power: indicates from 1 to 10 how much the strongest group is more cohesive than the opposite group
#'
#' - min_intra_STRONG: is the smallest similarity between the members of the strongest group which is still greater than the opposite group's intra-similarities and the inter-similarities between groups
#'
#' - max_intra_WEAK: is the largest similarity between the members of the weakest group which is still lower than the opposite group's intra-similarities and the inter-similarities
#'
#' - max_inter_similarities: is the largest similarity between members of the two groups
#'
#' While, top_pathways_l contains the data associated to each pathway of element that has been tested:
#'
#' - set: contains the significant molecules belonging to the pathway
#'
#' - set_counts: is the count matrix (e.g. genes per samples) with only the count values of the significant molecules belonging to the pathway/set
#'
#' - stats: is a dataframe indicating the statistics of the pathway
#'
#' - centrality: is a dataframe s.t. for each sample indicates how much is strongly similar in its groups versus not its group
#'
#' - orig_set contains all the original elements of the pathway
#'
#' top_pathways_el is the edge list containing the name of the significant pathways and the significant elements
#' @import matrixStats
#' @import data.table
#' @import scales
#' @import stats
#' @import Rfast
#' @import doParallel
#' @import foreach
#' @export
#'
find_PSN = function(counts, groups, pathways_l, sign_df,
                    pathway_type="generic_pathway", count_source="sequencing",
                    max_size=200, min_elements=5, n_top_pathways=100,
                    n_cores=2, keep_PSN=FALSE, ban=TRUE){
  #Extract the name of the groups in comparison
  groups_name=unique(groups)

  #Avoid generic pathways
  #Keep pathways having a number of elements lower than max_size
  keep=sapply(pathways_l,length)<=max_size
  pathways_l=pathways_l[keep]
  rm(max_size)

  if(ban){
    #Avoid context-specific pathways
    #Keep only the pathways having a name that does not include a word of the ban list
    np=names(pathways_l)
    data("ban_list")
    ban_names <- unique(grep(paste(ban_list,collapse="|"), np, value=FALSE, ignore.case = TRUE))
    if(length(ban_names)>0){
      pathways_l=pathways_l[-ban_names]
    }
  }

  #Get which kind of significant molecules are present:
  #Type 1: molecules which have a higher role and more cohesive in group 1 than group 2 are used
  #Type 2: molecules which have a higher role and more cohesive in group 2 than group 1 are used
  #Type -1: molecules which have a lower role and more cohesive in group 1 than group 2 are used
  #Type -2: molecules which have a lower role and more cohesive in group 1 than group 2 are used
  sign_df=sign_df[sign_df$sign_type!=0,]
  sign_types=unique(sign_df$sign_type)

  #Keep for each type of specific molecules, the pathways which fit them the most
  top_pathways_l=list()
  for(si in 1:length(sign_types)){
    #Select a type of significant molecules
    sign_type=sign_types[si]
    #Extract the molecules belonging to the type
    query_elements=rownames(sign_df[sign_df$sign_type==sign_type,])

    #Find the pathways having the most of significant molecules
    check_exist_pathways=TRUE
    min_elements0=min_elements
    min_elements1=6
    query_pathways_l=list()
    sel_path_l=list()

    while(check_exist_pathways & min_elements0>2){
      while(check_exist_pathways & min_elements1>=min_elements0){
        #Keep pathways with at least n significant molecules
        feat_freq=sapply(pathways_l,function(x){sum(query_elements %in% x)})
        keep=feat_freq>=min_elements1
        feat_freq=feat_freq[keep]
        query_pathways_l=pathways_l[keep]

        #Keep only the significant molecules in the best pathways
        sel_path_l=query_pathways_l
        sel_path_l=lapply(sel_path_l,function(x){x[x %in% query_elements]})
        sel_path_l=sel_path_l[sapply(sel_path_l,length)!=0]

        if(length(sel_path_l)<=20){
          min_elements1=min_elements1-1
          check_exist_pathways=TRUE
        }else{
          check_exist_pathways=FALSE
        }
      }

      if(length(sel_path_l)<=8){
        min_elements0=min_elements0-1
        check_exist_pathways=TRUE
      }else{
        check_exist_pathways=FALSE
      }
    }

    #In case, the pathways are more than the threshold, then keeps the best ones based on fold change and stability of their molecules
    if(length(sel_path_l)>n_top_pathways){
      feat_lfc=abs(sapply(sel_path_l,function(x){quantile(abs(sign_df$logFoldChange[rownames(sign_df)%in%x]), probs=0.8)}))
      feat_sta=abs(sapply(sel_path_l,function(x){quantile(abs(sign_df$stability[rownames(sign_df)%in%x]), probs=0.8)}))
      new_ord=order(feat_lfc,feat_sta,decreasing = TRUE)
      sel_path_l=sel_path_l[new_ord]
      sel_path_l=sel_path_l[1:n_top_pathways]
      rm(feat_lfc,feat_sta,new_ord)
    }
    rm(check_exist_pathways,query_pathways_l,min_elements1,min_elements0)

    #In case, a type of molecules does not enrich pathways then set every follow variable to 0 or NA
    #In case, a type of molecules enriches pathways then let's analyse their PSNs
    if(length(sel_path_l)==0){
      top_pathways_df=data.frame(pathways=NA,freq=0,sign_type=0)
      stats=data.frame(regulation=NA,group=NA,power=0,min_intra_STRONG=0,max_intra_WEAK=0,max_inter_similarities=0)
      top_pathways_df=cbind(top_pathways_df,stats)
      PSNs_l=list()
    }else{
      #Split the pathway list into chunks s.t. different cores can work simultaneously on different pathways
      n_pathways=length(sel_path_l)
      pathways_indxs=seq(1,n_pathways)
      max <- n_pathways/n_cores
      x <- seq_along(pathways_indxs)
      pathway_sets_indxs <- split(pathways_indxs, ceiling(x/max))

      #Create dataframe with the name of the top selected pathways and the number of elements inside
      top_pathways_df=data.frame(pathways=names(sel_path_l),freq=sapply(sel_path_l,length),sign_type=sign_type)
      rownames(top_pathways_df)=seq(1,nrow(top_pathways_df))
      rm(x,max,n_pathways,pathways_indxs)

      PSNs_l = list()
      PSNs_l = foreach(
        k_chunk = 1:length(pathway_sets_indxs),
        .inorder = FALSE,
        .noexport = c(),
        .verbose = F,
        #.errorhandling = "pass",
        .packages = c("matrixStats", "data.table", "scales", "stats","Rfast"),
        .export = c("build_PSN", "get_power","remove_low_sim","get_cohesive_score")
      ) %dopar%
      {

        #Get the indexes of the chunk of pathways that the core has to process
        pathway_set_indxs=pathway_sets_indxs[[k_chunk]]
        PSNs_chunk_l=list()

        #Set if the analysis is checking up or downregulated significant molecules/pathways
        if(sign_type>0){
          up=TRUE
        }else{
          up=FALSE
        }

        #Iterate over the pathways
        for(qi in pathway_set_indxs){
          #Extra pathway's data, pathway's name, significant molecules and submatrix of count
          pathway_name=names(sel_path_l)[qi]
          gs=sel_path_l[[qi]]
          gs_m=counts[gs,]

          #Build the PSN
          PSN=build_PSN(gs_m,up)

          #Determine the Power for an up and down regulated pathway
          PSN_stats=get_power(PSN, groups = groups)

          #Remove low similarities
          if(PSN_stats$power<3){
            PSN=remove_low_sim(PSN, groups = groups, dir_sign = sign_type)
            PSN_stats=get_power(PSN, groups = groups)
          }

          #Set up conditions to check up for coherence between sing. molecules, pathway and PSN
          check0=PSN_stats$power>0
          check1=(sign_type==1 & PSN_stats$group==groups_name[1])
          check2=(sign_type==2 & PSN_stats$group==groups_name[2])
          check1n=(sign_type==-1 & PSN_stats$group==groups_name[1])
          check2n=(sign_type==-2 & PSN_stats$group==groups_name[2])

          #Set meta-info based on the results of the checks
          if(check0){
            if(check1 | check2){
              best_stats=cbind(regulation="activated",PSN_stats)
              best_PSN=PSN
              centrality=get_cohesive_score(PSN=best_PSN, groups=groups)[,3]
            }
            if(check1n | check2n){
              best_stats=cbind(regulation="inhibited",PSN_stats)
              best_PSN=PSN
              centrality=get_cohesive_score(PSN=best_PSN, groups=groups)[,3]
            }
          }else{
            #In case of non-significant PSN, create empty meta-info
            best_stats=data.frame(regulation=NA,group=NA,power=0,
                                  min_intra_STRONG=0,max_intra_WEAK=0,max_inter_similarities=0)
            best_PSN=matrix(0,2,length(groups))
            centrality=rep(0,length(groups))
            names(centrality)=names(gs_m)
          }

          centrality=as.data.frame(t(centrality))
          rownames(centrality)=pathway_name
          colnames(centrality)=colnames(best_PSN)

          if(keep_PSN==FALSE){
            PSNs_chunk_l[[pathway_name]]=list(set=gs, set_counts=gs_m, stats=best_stats,
                                              centrality=centrality,
                                              orig_set=pathways_l[[pathway_name]])
          }else{
            PSNs_chunk_l[[pathway_name]]=list(set=gs, set_counts=gs_m, stats=best_stats,
                                              PSN=best_PSN, centrality=centrality,
                                              orig_set=pathways_l[[pathway_name]])
          }
        }

        return(PSNs_chunk_l)

      }

      #Format resulting list
      PSNs_l=do.call(c, PSNs_l)
      PSNs_l=PSNs_l[match(top_pathways_df$pathways,names(PSNs_l))]

      #Extract stats about the PSNs created for each corresponding pathway
      stats=lapply(PSNs_l,function(x){x$stats})
      stats=as.data.frame(data.table::rbindlist(stats))
      rownames(stats)=names(PSNs_l)

      #Merge pathway meta information
      top_pathways_df=cbind(top_pathways_df,stats)
    }

    if(sum(is.na(top_pathways_df$pathways))==nrow(top_pathways_df)){
      PSNs_l=list(NAN="NAN")
      names(PSNs_l)[1]=paste("run",sign_type,sep="")
    }

    if(si==1){
      top_pathways_dfs=top_pathways_df
      top_pathways_l=PSNs_l
    }else{
      top_pathways_dfs=rbind(top_pathways_dfs,top_pathways_df)
      top_pathways_l=c(top_pathways_l,PSNs_l)
    }

  }

  #Remove pathways which resulted not significant
  top_pathways_dfs$pathway_type=pathway_type
  top_pathways_dfs$count_source=count_source
  keep=(!is.na(top_pathways_dfs$pathways))
  top_pathways_dfs=top_pathways_dfs[keep,]
  top_pathways_l=top_pathways_l[keep]

  keep=top_pathways_dfs$power!=0
  top_pathways_dfs=top_pathways_dfs[keep,]
  top_pathways_l=top_pathways_l[keep]

  if(sum(duplicated(top_pathways_dfs$pathways))>0){
    #Order by power and minimum similarity for the signature class
    new_ord=order(top_pathways_dfs$regulation,decreasing = F)
    top_pathways_dfs=top_pathways_dfs[new_ord,]
    top_pathways_l=top_pathways_l[new_ord]

    #Find duplicated pathways
    keep=!duplicated(top_pathways_dfs$pathways)
    top_pathways_dfs=top_pathways_dfs[keep,]
    top_pathways_l=top_pathways_l[keep]
  }

  new_order=order(top_pathways_dfs$power,decreasing = T)
  top_pathways_dfs=top_pathways_dfs[new_order,]
  top_pathways_l=top_pathways_l[new_order]
  if(length(new_order)!=0){
    rownames(top_pathways_dfs)=seq(1,nrow(top_pathways_dfs))
  }

  if(nrow(top_pathways_dfs)>0){
    for(k in 1:nrow(top_pathways_dfs)){
      paths_el_df=data.frame(pathways=top_pathways_dfs$pathways[k],
                             sign_member=top_pathways_l[[top_pathways_dfs$pathways[k]]]$set,
                             sign_type=top_pathways_dfs$sign_type[k],test="PSN")
      if(k==1){
        top_pathways_el=paths_el_df
      }else{
        top_pathways_el=rbind(top_pathways_el,paths_el_df)
      }
    }

    top_pathways_el$pathway_type=pathway_type
    top_pathways_el$count_source=count_source
  }else{
    top_pathways_el=na.omit(data.frame(pathways=NA,sign_member=NA,sign_type=NA,test=NA,pathway_type=NA,count_source=NA))
  }

  res_l=list(top_pathways_l=top_pathways_l,top_pathways_df=top_pathways_dfs,top_pathways_el=top_pathways_el)
  return(res_l)
}

#' Combines resulting pathways from multiple integrations
#'
#' Combines resulting pathways from multiple integrations
#' Returns a list with one matrix and one edge list dataframe with the pathways' information produced with different omics
#'
#' @param omics omics list
#' @param start character string pointing to the position of the omics list in the data list
#' @return list of two elements: top_pathways_df and top_pathways_el with pathways' information produced with different omics
merge_pathway_analysis = function(omics,start){
  first=TRUE
  one_level_path=paste(start,"$omics$%s$pathway_analysis$top_pathways_l$%s",sep="")
  two_level_path=paste(start,"$omics$%s$pathway_analysis$%s$top_pathways_l$%s",sep="")

  k=1;i=1;
  for(k in 1:length(omics)){
    level1=names(omics[k])
    pathway_level=sum("pathway_analysis" %in% names(omics[[k]]))>0
    if(!pathway_level){
      next;
    }
    subres=omics[[k]]$pathway_analysis
    pathway_level=sum("top_pathways_l" %in% names(subres))>0

    if(pathway_level){
      df=subres$top_pathways_df
      el=subres$top_pathways_el
      one_level_path1=sprintf(one_level_path,level1,df$pathways)
      df$path2pathway=one_level_path1

      if(first){
        dfs=df
        els=el
        first=FALSE
      }else{
        dfs=rbind(dfs,df)
        els=rbind(els,el)
      }

    }else{
      for(i in 1:length(subres)){
        level2=names(subres[i])
        pathway_level=sum("top_pathways_l" %in% names(subres[[i]]))>0
        if(!pathway_level){
          next;
        }
        df=subres[[i]]$top_pathways_df
        el=subres[[i]]$top_pathways_el
        two_level_path1=sprintf(two_level_path,level1,level2,df$pathways)
        df$path2pathway=two_level_path1

        if(first){
          dfs=df
          els=el
          first=FALSE
        }else{
          dfs=rbind(dfs,df)
          els=rbind(els,el)
        }
      }
    }
  }
  res=list(top_pathways_df=dfs,top_pathways_el=els)
  return(res)
}

#' Retrieve pathway's data from path
#'
#' Retrieve pathway's data from path
#'
#' @param data_l omics list
#' @param path2path character string pointing to the position of the omics list in the data list
#' @return list of two elements: top_pathways_df and top_pathways_el with pathways' information produced with different omics
#' @export
get_pathway_data = function(data_l,path2path){
  path2path1=unlist(strsplit(path2path,split="$",fixed = TRUE))
  res_l=data_l[[path2path1]]
  return(res_l)
}


#' Find all enriched pathways (dangerous)
#'
#' Remove the excessive context-specific pathways (ban_list).
#' Remove the pathways which size is bigger than max_size (max_size:200).
#' Keep all the pathways having significant elements (pathway_df).
#'
#' @param pathways_l list of pathways
#' @param sign_df dataframe generated by find_SDR
#' @param pathway_type Default generic_pathway, label indicating the type of pathways (e.g. "gene_canonical_pathways")
#' @param count_source label sequencing, label indicating the source used to find the significant molecules (e.g. "gene_expression", "mutation")
#' @param max_size Default 200, integer filtering out the pathways with more elements than this threshold
#' @param min_elements Default 1, integer filtering out the pathways containing less than this threshold of significant molecules
#' @param n_top_pathways Default 100, integer setting how many best pathway-specific PSNs to retrieve
#' @param n_cores Default 2, integer setting the number of cores to use for running the function in parallel
#' @param keep_PSN Default FALSE, boolean, do not keep the PSN generated from a pathway
#' @param ban Default TRUE, boolean, remove excessive context-specific pathways (e.g. "SOUND", "STABILIZATION", "ODONTOGENESIS", "PREGNANCY")
#' @return list of two elements: top_pathways_l and top_pathways_df.
#' top_pathways_df details the pathways enriched by the significant molecules.
#' It describes them with the following column features:
#'
#' - pathways: pathway name
#'
#' - molecules: significantly different molecule between groups that has been found associated to the enriched pathway
#'
#' - barcode: direction of deregulation of the molecule
#'
#' While, top_pathways_l contains the enriched pathways with all their annotated molecules
#' @import matrixStats
#' @import data.table
#' @import scales
#' @import stats
#' @import Rfast
find_mutated_pathways = function(pathways_l, sign_df, gex,
                                 pathway_type="generic_pathway", count_source="sequencing",
                                 max_size=200, min_elements=1, n_top_pathways=200,
                                 n_cores=2, keep_PSN=FALSE, ban=TRUE){

  if(ban){
    #Avoid context-specific pathways
    #Keep only the pathways having a name that does not include a word of the ban list
    np=names(pathways_l)
    data("ban_list")
    ban_names <- unique(grep(paste(ban_list,collapse="|"), np, value=FALSE, ignore.case = TRUE))
    if(length(ban_names)>0){
      pathways_l=pathways_l[-ban_names]
    }
  }

  #Avoid generic pathways
  #Keep pathways having a number of elements lower than max_size
  keep=sapply(pathways_l,length)<=max_size
  pathways_l=pathways_l[keep]
  rm(max_size)

  #Get which kind of significant molecules are present:
  #Type 9: molecules are used collectively to understand which pathway fit them the most
  #Type 1: molecules which have a higher role and more cohesive in group 1 than group 2 are used
  #Type 2: molecules which have a higher role and more cohesive in group 2 than group 1 are used
  #Type -1: molecules which have a lower role and more cohesive in group 1 than group 2 are used
  #Type -2: molecules which have a lower role and more cohesive in group 1 than group 2 are used
  sign_df=sign_df[sign_df$sign_type!=0,]
  sign_types=unique(sign_df$sign_type)

  #Keep for each type of specific molecules, the pathways which fit them the most
  top_pathways_l=list()
  first=TRUE
  for(si in 1:length(sign_types)){
    #Select a type of significant molecules
    sign_type=sign_types[si]
    #Extract the molecules belonging to the type
    query_elements=rownames(sign_df[sign_df$sign_type==sign_type,])

    #Find the pathways having the most of significant molecules
    check_exist_pathways=T
    min_elements1=min_elements
    while(check_exist_pathways & min_elements1>0){
      #Keep pathways with at least n molecules
      feat_freq=sapply(pathways_l,function(x){sum(query_elements %in% x)})
      keep=feat_freq>=min_elements1
      feat_freq=feat_freq[keep]
      query_pathways_l=pathways_l[keep]

      #Keep n pathways with the most number of molecules
      sel_path_l=query_pathways_l
      sel_path_l=lapply(sel_path_l,function(x){x[x %in% query_elements]})
      sel_path_l=sel_path_l[sapply(sel_path_l,length)!=0]
      sel_full_path_l=query_pathways_l[names(sel_path_l)]

      if(length(sel_path_l)<=10){
        min_elements1=min_elements1-1
      }else{
        check_exist_pathways=FALSE
      }
    }

    #In case, the pathways are more than the threshold, then keeps the best ones based on fold change and stability of their molecules
    if(length(sel_path_l)>n_top_pathways){
      feat_lfc=abs(sapply(sel_path_l,function(x){quantile(abs(sign_df$logFoldChange[rownames(sign_df)%in%x]), probs=0.8)}))
      feat_sta=abs(sapply(sel_path_l,function(x){quantile(abs(sign_df$stability[rownames(sign_df)%in%x]), probs=0.8)}))
      new_ord=order(feat_lfc,feat_sta,decreasing = TRUE)
      sel_path_l=sel_path_l[new_ord]
      sel_path_l=sel_path_l[1:n_top_pathways]
      sel_full_path_l=sel_full_path_l[names(sel_path_l)]
    }

    rm(check_exist_pathways,query_pathways_l,min_elements1)

    if(length(sel_path_l)==0){
      next;
    }

    #Save
    if(length(sel_path_l)>0 & first==TRUE){
      #Create an edgle list dataframe with the enriched pathways and the significant molecules mapped into them
      y=unlist(sel_path_l)
      top_pathways_el=data.frame(row.names = seq(1,length(y)),
                                 pathways=gsub("[[:digit:]]", "", names(y)),
                                 sign_member=y,
                                 test="PROB",
                                 sign_type=sign_type)

      top_pathways_els=top_pathways_el
      sel_full_path_ls=sel_full_path_l
      first=FALSE
    }
    if(length(sel_path_l)>0 & first==FALSE){
      #Create an edgle list dataframe with the enriched pathways and the significant molecules mapped into them
      y=unlist(sel_path_l)
      top_pathways_el=data.frame(row.names = seq(1,length(y)),
                                 pathways=gsub("[[:digit:]]", "", names(y)),
                                 sign_member=y,
                                 sign_type=sign_type,
                                 test="PROB")

      top_pathways_els=rbind(top_pathways_els,top_pathways_el)
      sel_full_path_ls=c(sel_full_path_ls,sel_full_path_l)
    }
  }

  if(length(sel_path_l)>0){
    top_pathways_els$pathway_type=pathway_type
    top_pathways_els$count_source=count_source
  }else{
    top_pathways_els=na.omit(data.frame(pathways=NA,sign_member=NA,sign_type=NA,test=NA,pathway_type=NA,count_source=NA))
  }

  if(length(sel_path_l)>0){

    res_el=top_pathways_els
    gex_df=gex$top_pathways_df
    gex_el=gex$top_pathways_el

    gex_df$mutated=FALSE
    gex_el$mutated=FALSE

    sign_types=unique(res_el$sign_type)
    mut_genes=NA
    for(sign_type in sign_types){
      res_el1=res_el[abs(res_el$sign_type)==abs(sign_type),]
      gex_el1=gex_el[abs(gex_el$sign_type)==abs(sign_type),]
      mut_genes=c(mut_genes,intersect(gex_el1$sign_member,res_el1$sign_member))
    }
    mut_genes=mut_genes[!is.na(mut_genes)]

    if(length(mut_genes)>0){
      gex_el$mutated[gex_el$sign_member %in% mut_genes]=TRUE
      mutated_pathways=gex_el$pathways[gex_el$mutated]
      gex_df$mutated[gex_df$pathways %in% mutated_pathways]=TRUE
    }

    gex$top_pathways_df=gex_df[,c(seq(1,ncol(gex_df)-2),ncol(gex_df),(ncol(gex_df)-1))]
    gex$top_pathways_el=gex_el

  }

  return(gex)
}

#' Find significant regulatory targets with ecdf test
#'
#' Find the log fold change of the targets and non-targets.
#' Test if the two lists of fold changes are statistically different using ks.test.
#' Determine if the targets are enriching positively or negatively with respect the non-targets.
#' For each set of statistically significant targets, return the regulatory element (e.g. miRNA) with its targets.
#'
#' @param nc_l list of sets, each set called as regulatory element contains the names of the element's targets
#' @param nc_sign_l list of significant sets, each set called as deregulated regulatory element contains the names of the element's deregulated targets
#' @param nc_tT_ov dataframe of statics regarding the regulatory elements, elements must be at the rows and there must be a column logFoldChange
#' @param target_tT_ov dataframe of statics regarding the regulatory elements' targets, targets must be at the rows and there must be a column logFoldChange
#' @param pathway_type Default generic_pathway, label indicating the type of pathways (e.g. "gene_canonical_pathways")
#' @param count_source label sequencing, label indicating the source used to find the significant molecules (e.g. "gene_expression", "mutation")
#' @param anti_corr default FALSE, indicates if the regulatory element and its targets must be anti-correlated in fold changes
#' @return dataframe with two columns: regulatory element (e.g. miRNA) and its significant target/s
#' @importFrom stats na.omit
#' @importFrom stats ks.test
#' @export
find_cdf_pathways = function(nc_l, nc_sign_l, nc_tT_ov, target_tT_ov,
                             pathway_type="generic_pathway", count_source="sequencing",
                             anti_corr=FALSE){

  first = TRUE

  if(!is.null(nc_l) & !is.null(nc_l) & !is.null(nc_tT_ov) & !is.null(target_tT_ov)){
    if(length(nc_l)!=0 & length(nc_sign_l)!=0 & nrow(nc_tT_ov)>1 & nrow(target_tT_ov)>1){

    nc_names=names(nc_sign_l)
    options(warn=-1)

    for(k in 1:length(nc_names)){
      nc_name=nc_names[k]
      dir=nc_tT_ov[nc_name,]$logFoldChange

      targs=nc_l[[nc_name]]

      m_targs=stats::na.omit(target_tT_ov[rownames(target_tT_ov) %in% targs,])
      v_targs1=m_targs$logFoldChange

      if(length(v_targs1)==0){

        area=0
        ks_test=999
        sign_type=0

      }else{
        if(mean(v_targs1)>0){
          sign_type=1
        }else{
          sign_type=2
        }

        m_no=stats::na.omit(target_tT_ov[!(rownames(target_tT_ov) %in% targs),])
        v_no1=m_no$logFoldChange

        #https://stats.stackexchange.com/questions/113094/estimating-the-area-between-two-ecdfs
        area=mean(v_targs1) - mean(v_no1)

        #https://colinfay.me/intro-to-r/probability-distributions.html
        ks_test=suppressWarnings(stats::ks.test(v_targs1, v_no1, exact=FALSE)$p.value)

      }
      if(ks_test<=0.05){
        if(anti_corr==TRUE){
          if((dir>0 & area<0) | (dir<0 & area>0)){
            path_df=data.frame(pathways=nc_name,sign_member=nc_sign_l[[nc_name]],sign_type=sign_type)
            if(first==TRUE){
              paths_df=path_df
              first=FALSE
            }else{
              paths_df=rbind(paths_df,path_df)
            }
          }
        }else{
          path_df=data.frame(pathways=nc_name,sign_member=nc_sign_l[[nc_name]],sign_type=sign_type)
          if(first==TRUE){
            paths_df=path_df
            first=FALSE
          }else{
            paths_df=rbind(paths_df,path_df)
          }
        }
      }
    }
    options(warn=0)
    }
  }

  if(first==FALSE){
    paths_df$test="CDF"
    paths_df$pathway_type=pathway_type
    paths_df$count_source=count_source
  }else{
    paths_df=na.omit(data.frame(pathways=NA,sign_member=NA,sign_type=NA,test=NA,pathway_type=NA,count_source=NA))
  }

  return(paths_df)
}

#' Combine results from testing pathways with ECDF and PSN
#'
#' Combine results from testing pathways with ECDF and PSN
#'
#' @param el1 edge list containing elements connections that have been found significant based on PSN
#' @param el2 edge list containing elements connections that have been found significant based on ECDF
#' @return edge list containing elements connections that have been found significant based on PSN/ECDF and PSN+ECDF
combine_test_results = function(el1,el2,target_name="test"){
  if(nrow(el1)>0 & nrow(el2)>0){
    tmp=rbind(el1,el2)
    targ=which(colnames(tmp)==target_name)
    tmp[duplicated(tmp[,-targ]) | duplicated(tmp[,-targ],fromLast=TRUE),targ]="CDF+PSN"
    return(tmp)
  }else{
    if(nrow(el1)>0){
      return(el1)
    }else{
      return(el2)
    }
  }
}


#' Complete the network of multi-omics molecules
#'
#' A mutation can alter a pathway.
#' A lncRNA can alter another pathway.
#' The two pathways can overlap.
#' This function introduces new connections to the edge list dataframe.
#' A row to connect the mutation to the lncRNA's pathway.
#' A row for the opposite.
#'
#' @param df character dataframe, first column contains the pathway names, second column contains the molecules enriching the corresponding row pathway
#' @param pathway_l list of pathways with the names that match the ones present in the first column of the dataframe
#' @return Updated dataframe
#' @export
#'
do_complete_net = function(df,pathway_l){
  # Check that the input 'df' is a data frame with at least two columns
  if (!is.data.frame(df) || ncol(df) < 2) {
    stop("Input 'df' must be a data frame with at least two columns.")
  }

  # Check that the input 'pathway_l' is a named list
  if (!is.list(pathway_l) || sum(names(pathway_l) %in% df[,1])==0) {
    stop("Input 'pathway_l' must be a named list with names that match the first column of 'df'.")
  }

  for(i in 1:nrow(df)){
    cat("i",i,"\n")
    i_pathway_name=df[i,1]
    i_mol_name=df[i,2]
    i_set=pathway_l[[pathway_name]]

    k=i+1
    for(j in k:nrow(df)){
      j_pathway_name=df[j,1]
      j_mol_name=df[j,2]
      j_set=pathway_l[[pathway_name]]

      overlap=length(intersect(i_set,j_set))
      if(overlap>0){
        df=rbind(df,c(j_pathway_name,i_mol_name))
        df=rbind(df,c(i_pathway_name,j_mol_name))
      }
    }
  }
  df=unique(df)
  return(df)
}
